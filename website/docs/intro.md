---
sidebar_position: 1
title: SKIE Intro
---

# SKIE

Skie is a compiler plugin that generates Swift wrappers of the Objective-C headers generated by the Kotlin compiler. Its goal is to improve interoperability between Kotlin and Swift by recreating features supported by both languages, but lost in the translation from Kotlin to Objective-C to Swift.

SKIE currently supports the following features:

- Sealed classes/interfaces
- Exhaustive enums
- Default arguments

To see how to add SKIE to your project, check out the [Installation doc](/docs/Installation.mdx).

*Please note that Skie is still under active development, has not been publicly released, and should not be used in any production project.*

## Supported features

### Sealed classes/interfaces

SKIE allows you to exhaustively switch on sealed Kotlin hierarchies from Swift. For example, consider the following Kotlin code:

```kotlin
sealed interface KotlinSealedInterface {
    class Success(val data: List<Any>) : KotlinSealedInterface
    class Error(val message: String) : KotlinSealedInterface
    object Loading : KotlinSealedInterface
}
```

In Kotlin you can write this:

```kotlin
when (sealedInterface) {
    is KotlinSealedInterface.Success -> configureWithData(sealedInterface.data)
    is KotlinSealedInterface.Error -> configureForErrorMessage(sealedInterface.message)
    is KotlinSealedInterface.Loading -> configureForLoading()
}
```

In the above example, the compiler ensures that the `when` expression lists all possible cases (i.e. that it is exhaustive). The compiler also smart-casts the `sealedInterface` expression to the correct type. The smart-cast allows the developer to access the inner properties of each type without an additional cast.

To support this feature in Swift, SKIE generates code that can be reduced to this:

```swift
enum SwiftWrapperEnum {
    case Success(KotlinSealedInterfaceSuccess)
    case Error(KotlinSealedInterfaceError)
    case Loading(KotlinSealedInterfaceLoading)
}

func onEnum(of sealed: KotlinSealedInterface) -> SwiftWrapperEnum {
    if let sealed = sealed as? KotlinSealedInterfaceSuccess {
        return SwiftWrapperEnum.Success(sealed)
    } else if let sealed = sealed as? KotlinSealedInterfaceError {
        return SwiftWrapperEnum.Error(sealed)
    } else if sealed is KotlinSealedInterfaceLoading {
        return SwiftWrapperEnum.Loading
    } else {
        fatalError("Unknown subtype. This error should not happen under normal circumstances since KotlinSealedInterace is sealed.")
    }
}
```

The `onEnum(of:)` function wraps the Kotlin object in a Swift enum.

SKIE leverages the fact that Swift `switch` statements **do not** always require a `default` case. A `default` is **not** required if every possible value of the type being considered is matched by one of the `switch` statement's cases (e.g. a `switch` that takes an enum and has a `case` for each and every `case` in that enum.)

To simulate Kotlin's smart-casting we use an enum with associated values.

Thanks to the above code you can now write this:

```swift
switch onEnum(of: sealedInterface) {
case .Success(let sealedInterface):
    configureForSuccess(withData: sealedInterface.data)
case .Error(let sealedInterface):
    configureForError(withMessage: sealedInterface.message)
case .Loading:
    configureForLoading()
}
```

If you do not need the smart-casting, you can write just this:

```swift
switch onEnum(of: sealedInterface) {
case .Success:
    print("success!")
case .Error:
    fatalError()
case .Loading:
    configureForLoading()
}
```

### Exhaustive enums

The Kotlin compiler (without SKIE) generates Kotlin enums as Objective-C classes (albeit with restricted subclassing). As a result, Swift code cannot leverage some of its language features in regards to enums (mainly exhaustive switching).

SKIE adds back this functionality by generating a Swift version of the given Kotlin enum. The Swift enum is accessible without any extra code (like the `onEnum` in the case of sealed classes).
This is possible because SKIE generates a so-called bridging header that tells the Swift compiler how to do the conversion automatically.

For example, consider following Kotlin code:

```kotlin
enum class Direction {
    NORTH, SOUTH, EAST, WEST
}
```

Without SKIE you can still use `switch` from Swift code, like this:

```swift
switch (direction) {
case .north: print("NORTH")
case .south: print("SOUTH")
case .east: print("EAST")
case .west: print("WEST")
default: print("Unknown")
}
```

Note that the `default` case is required. However, with SKIE, the `default` case is no longer necessary. Instead, you will see a compiler warning similar to this one:

```
warning: default will never be executed
default: print("Unknown")
```

### Default arguments/parameters

Default arguments (or parameters) are a feature in both [Kotlin](https://kotlinlang.org/docs/functions.html#default-arguments) and [Swift](https://docs.swift.org/swift-book/LanguageGuide/Functions.html#ID169) that allows caller functions to omit arguments when the missing arguments are provided by the called function. Unfortunately, Objective-C does not support default arguments in any way. Therefore, Swift must always specify all arguments when calling Kotlin functions.

Default arguments are implemented differently in Kotlin and Swift, so the two languages have different semantics for the feature. For example, Kotlin default arguments can access the values of previous function parameters as well as the `this` expression (which is `self` in Swift).

However, Swift default parameters must be globally available. As a result, SKIE cannot generate Swift functions with default arguments (at least not in all cases). To solve this issue, SKIE generates Kotlin overloads of the given functions to match all possible ways to call that functions.

For example, let's take a `data class`:

```kotlin
data class User(
    val name: String,
    val age: Int
)
```

Kotlin data classes have an automatically generated method named `copy` that creates a new instance of the data class with some values modified. For our data class `User` up above, the method can be written as:

```kotlin
fun User.copy(name: String = this.name, age: Int = this.age) = User(name, age)
```

Without SKIE the `copy` method is exposed to Swift under the following signature: `User.doCopy(name:age:)` due to a naming collision with an Objective-C method named `copy`. Since Swift cannot use Kotlin default arguments, all parameters must be provided, which defeats the purpose of the Kotlin `copy` method.

SKIE generates additional Kotlin overloads, that are visible from Swift under the following signatures:

- `User.doCopy()`
- `User.doCopy(name:)`
- `User.doCopy(age:)`

These overloads allow Swift to call `copy` method as if the default arguments were directly supported.

#### Limitations

While this approach to default arguments is completely transparent from Swift, it has some drawbacks:

- It does not support interface methods (all other types of functions are supported, including interface extensions).
- Generated overloads may cause resolution conflicts.
- The number of generated overloads is `O(2^n)` where `n` is the number of default arguments (not all parameters).

SKIE tries to avoid generating functions that would cause conflicts, however the implementation is not complete yet. Specifically, it does not yet properly handle inheritance, generics, and generated overloads of multiple functions with default arguments. If you run into this issue, you might have to disable the code generation for one of the functions (see the Local section of [the Configuration doc](/Configuration.md)).

Alternatively, you can rename one of the conflicting functions (or their parameters).

Since it is not possible to generate exponential numbers of functions, the number of default arguments supported is limited to 5, so that at most 31 additional functions will be generated per function with default arguments. If a function has more than 5 default arguments, SKIE will not generate any extra functions.

The limit of 5 was chosen as the result of internal experiments, but that number might change. For now, we think it's a suitable balance between the number of supported cases (since not many functions exceed that number) and the overhead introduced in the form of compilation time and binary size.

The maximum number of default arguments can be explicitly configured using the `DefaultArgumentInterop.MaximumDefaultArgumentCount` key/annotation (see the Local section of [the Configuration doc](/docs/Configuration.md).

*NOTE: All of the above-mentioned problems might be mitigated in the future versions of SKIE. For instance, the limit on the number of default arguments may increase in the future as we test the plugin on larger projects.*
