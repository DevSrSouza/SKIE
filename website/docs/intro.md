---
sidebar_position: 1
title: SKIE Intro
---

# SKIE

SKIE is a compiler plugin that generates Swift wrappers of the Objective-C headers generated by the Kotlin compiler. Its goal is to improve interoperability between Kotlin and Swift by recreating features supported by both languages, but lost in the translation from Kotlin to Objective-C to Swift.

SKIE currently supports the following features:

- Coroutines interop
- Fixing unnecessarily mangled function names
- Sealed classes/interfaces
- Exhaustive enums
- Default arguments

To see how to add SKIE to your project, check out the [Installation doc](/docs/Installation.mdx).

*Please note that SKIE is still under active development, has not been publicly released, and should not be used in any
production project.*

## Supported features

### Coroutines Interop

While it's possible to use Kotlin Coroutines in KMM, the support is far from complete.
One of the main goals of SKIE is to change that.

Currently, SKIE has support for `suspend` functions and support for `Flows` is underway.

The problem with suspend functions is that ObjC has no such concept.
Therefore, the Kotlin compiler exposes suspend functions as callbacks.
This approach has the following problems:

- It has an ugly syntax that leads to callback hell (which is what suspend functions were meant to solve in the first place).
- Suspend function can be only called from Swift from the main thread (otherwise it results in a runtime crash).
- It's not possible to cancel execution of such function from Swift.

The ugly syntax was already solved when Swift 5.5 added `async`/`await` with interop for legacy ObjC functions.
Thanks to that Kotlin suspend functions can also be called using the `async`/`await` syntax.
For example: `suspend fun foo(): Int = 0` can now be called as `let result = try? await foo()`.

But this was just a syntax change, the other problems were unaffected.
SKIE lifts the remaining restrictions by generating Swift wrapper functions.
From the user perspective these wrappers are (almost) transparent.
They have the same signature, so you mostly don't need to change existing code. (Except in the case of generic classes as explained below.)

These wrappers can be called from any thread, and they also bridge cancellation between Swift and Kotlin.
Meaning you can cancel Kotlin suspend function from Swift as you would with any other Swift async function.
If the suspend function is canceled from Kotlin, the Swift caller receives `CancellationError` as would be the case with regular Swift async functions.
Therefore, from Swift point of view Kotlin suspend functions are indistinguishable from true Swift async functions.
And the called suspend function behaves as if it was called from another Kotlin suspend function.

These wrappers are generated for all types of suspend functions (global functions, member functions, extensions).
However, there is one big limitation: generic classes.
In the case of generic classes it's impossible to generate the same Swift wrapper as for other functions. (Due to limitations in Swift-ObjC interop.)

This limitation is very similar to Kotlin interface extensions (ObjC supports only class extensions).
The Kotlin compiler circumvents this problem by generating the function as a static function in the file class.
For example:

```kotlin title=I.kt
interface I

// The `foo` function is exported as `IKt.foo(_:)` (the first parameter is the extension receiver).
fun I.foo()
```

SKIE does the same thing for suspend functions of generic classes (both for member functions and extensions).
For example:

```kotlin title=A.kt
class A {

    suspend fun foo(): Int = 0
}
```

Which can be called like so:

```swift
try await AKt.foo(A())
```

Another limitation is that the generated wrappers cannot be directly overridden (they are just extensions).
Instead, you need to override the original suspend method.
SKIE hides the original methods by prefixing them with `__`.
Therefore, it's possible to override that method using it's prefixed name.
For example:

```kotlin
open class A {

    open suspend fun foo(): Int = 0
}
```

```swift
class B: A {

    override func __foo() async throws -> KotlinInt {
        return KotlinInt(1)
    }
}
```

But make sure to not call suspend functions by the prefixed name - use the generated wrapper instead. (Otherwise you would lose the benefits that SKIE brings.)

### Fixing unnecessarily mangled function names

Kotlin, ObjC and Swift each have a different level of support for function overloading.
Kotlin distinguishes overloads by their parameter types.
ObjC uses argument labels (parameter names in Kotlin) but does not use the parameter types.
Swift combines these two approaches and allows for overloads to have the same parameters types if some argument labels are different.

The Kotlin compiler solves these differences by adding `_` at the end of the function identifier (or at the end of the last argument label).
The problem, that SKIE addresses, is that the Kotlin compiler uses the same conflict detection rules for both ObjC and Swift.
As a result Swift function names are in many occasions unnecessarily mangled. For example:

```kotlin
fun foo(i: Int)

fun foo(i: String)
```

would translate to: `foo(i:)` and `foo(i_:)` - even-though the underscore is not necessary for Swift to call the correct function.

SKIE implements its own conflict resolution algorithm that removes these unnecessary underscores.

However, there are still some occasions where these underscore are necessary (meaning SKIE cannot remove them):

*Non-exposed classes used as parameter type* - Some types (like Value classes) are not exposed to ObjC.
Instead, the compiler replaces these types with some other supported type (in case of value classes it's the wrapped type).
For this reason some functions might end up with the same signature in Swift (even-though they have different signatures in Kotlin).
For example:

```kotlin
value class V(val value: Int)

fun foo(v: V)

fun foo(v: Int)
```

*Properties and parameterless functions* - In Kotlin it's completely fine to have a property with the same name as a parameterless functions.
For example:

```kotlin
fun foo(): Int

val foo: Int
```

The problem is that Swift cannot distinguish these two declarations.
This is not an issue you would notice without using SKIE because the Kotlin compiler uses a different workaround.
Unfortunately, this workaround cannot be used by SKIE because it only works due to the Swift-ObjC interop.
SKIE generates true Swift code, and therefore, SKIE has no option but to add these underscores.

### Sealed classes/interfaces

SKIE allows you to exhaustively switch on sealed Kotlin hierarchies from Swift. For example, consider the following Kotlin code:

```kotlin
sealed interface KotlinSealedInterface {
    class Success(val data: List<Any>) : KotlinSealedInterface
    class Error(val message: String) : KotlinSealedInterface
    object Loading : KotlinSealedInterface
}
```

In Kotlin you can write this:

```kotlin
when (sealedInterface) {
    is KotlinSealedInterface.Success -> configureWithData(sealedInterface.data)
    is KotlinSealedInterface.Error -> configureForErrorMessage(sealedInterface.message)
    is KotlinSealedInterface.Loading -> configureForLoading()
}
```

In the above example, the compiler ensures that the `when` expression lists all possible cases (i.e. that it is exhaustive). The compiler also smart-casts the `sealedInterface` expression to the correct type. The smart-cast allows the developer to access the inner properties of each type without an additional cast.

To support this feature in Swift, SKIE generates code that can be reduced to this:

```swift
enum SwiftWrapperEnum {
    case Success(KotlinSealedInterfaceSuccess)
    case Error(KotlinSealedInterfaceError)
    case Loading(KotlinSealedInterfaceLoading)
}

func onEnum(of sealed: KotlinSealedInterface) -> SwiftWrapperEnum {
    if let sealed = sealed as? KotlinSealedInterfaceSuccess {
        return SwiftWrapperEnum.Success(sealed)
    } else if let sealed = sealed as? KotlinSealedInterfaceError {
        return SwiftWrapperEnum.Error(sealed)
    } else if sealed is KotlinSealedInterfaceLoading {
        return SwiftWrapperEnum.Loading
    } else {
        fatalError("Unknown subtype. This error should not happen under normal circumstances since KotlinSealedInterace is sealed.")
    }
}
```

The `onEnum(of:)` function wraps the Kotlin object in a Swift enum.

SKIE leverages the fact that Swift `switch` statements **do not** always require a `default` case. A `default` is **not
** required if every possible value of the type being considered is matched by one of the `switch` statement's cases (e.g. a `switch` that takes an enum and has a `case` for each and every `case` in that enum.)

To simulate Kotlin's smart-casting we use an enum with associated values.

Thanks to the above code you can now write this:

```swift
switch onEnum(of: sealedInterface) {
case .Success(let sealedInterface):
    configureForSuccess(withData: sealedInterface.data)
case .Error(let sealedInterface):
    configureForError(withMessage: sealedInterface.message)
case .Loading:
    configureForLoading()
}
```

If you do not need the smart-casting, you can write just this:

```swift
switch onEnum(of: sealedInterface) {
case .Success:
    print("success!")
case .Error:
    fatalError()
case .Loading:
    configureForLoading()
}
```

### Exhaustive enums

The Kotlin compiler (without SKIE) generates Kotlin enums as Objective-C classes (albeit with restricted subclassing). As a result, Swift code cannot leverage some of its language features in regards to enums (mainly exhaustive switching).

SKIE adds back this functionality by generating a Swift version of the given Kotlin enum. The Swift enum is accessible without any extra code (like the `onEnum` in the case of sealed classes).
This is possible because SKIE generates a so-called bridging header that tells the Swift compiler how to do the conversion automatically.

For example, consider following Kotlin code:

```kotlin
enum class Direction {
    NORTH, SOUTH, EAST, WEST
}
```

Without SKIE you can still use `switch` from Swift code, like this:

```swift
switch (direction) {
case .north: print("NORTH")
case .south: print("SOUTH")
case .east: print("EAST")
case .west: print("WEST")
default: print("Unknown")
}
```

Note that the `default` case is required. However, with SKIE, the `default` case is no longer necessary. Instead, you will see a compiler warning similar to this one:

```
warning: default will never be executed
default: print("Unknown")
```

### Default arguments/parameters

Default arguments (or parameters) are a feature in both [Kotlin](https://kotlinlang.org/docs/functions.html#default-arguments) and [Swift](https://docs.swift.org/swift-book/LanguageGuide/Functions.html#ID169) that allows caller functions to omit arguments when the missing arguments are provided by the called function. Unfortunately, Objective-C does not support default arguments in any way. Therefore, Swift must always specify all arguments when calling Kotlin functions.

Default arguments are implemented differently in Kotlin and Swift, so the two languages have different semantics for the feature. For example, Kotlin default arguments can access the values of previous function parameters as well as the `this` expression (which is `self` in Swift).

However, Swift default parameters must be globally available. As a result, SKIE cannot generate Swift functions with default arguments (at least not in all cases). To solve this issue, SKIE generates Kotlin overloads of the given functions to match all possible ways to call that functions.

For example, let's take a `data class`:

```kotlin
data class User(
    val name: String,
    val age: Int
)
```

Kotlin data classes have an automatically generated method named `copy` that creates a new instance of the data class with some values modified. For our data class `User` up above, the method can be written as:

```kotlin
fun User.copy(name: String = this.name, age: Int = this.age) = User(name, age)
```

Without SKIE the `copy` method is exposed to Swift under the following signature: `User.doCopy(name:age:)` due to a naming collision with an Objective-C method named `copy`. Since Swift cannot use Kotlin default arguments, all parameters must be provided, which defeats the purpose of the Kotlin `copy` method.

SKIE generates additional Kotlin overloads, that are visible from Swift under the following signatures:

- `User.doCopy()`
- `User.doCopy(name:)`
- `User.doCopy(age:)`

These overloads allow Swift to call `copy` method as if the default arguments were directly supported.

#### Limitations

While this approach to default arguments is completely transparent from Swift, it has some drawbacks:

- It does not support interface methods (all other types of functions are supported, including interface extensions).
- The number of generated overloads is `O(2^n)` where `n` is the number of default arguments (not all parameters).

Since it is not possible to generate exponential numbers of functions, the number of default arguments supported is limited to 5, so that at most 31 additional functions will be generated per function with default arguments. If a function has more than 5 default arguments, SKIE will not generate any extra functions.

The limit of 5 was chosen as the result of internal experiments, but that number might change. For now, we think it's a suitable balance between the number of supported cases (since not many functions exceed that number) and the overhead introduced in the form of compilation time and binary size.

The maximum number of default arguments can be explicitly configured using the `DefaultArgumentInterop.MaximumDefaultArgumentCount` key/annotation (see the Local section of [the Configuration doc](/docs/Configuration/Configuration.md).

*NOTE: All of the above-mentioned problems might be mitigated in the future versions of SKIE. For instance, the limit on
the number of default arguments may increase in the future as we test the plugin on larger projects.*
