---
sidebar_position: 1
title: SKIE Intro
---

# SKIE

SKIE is a compiler plugin that compliments Kotlin/Native by generating Swift wrappers of the Objective-C headers generated by the Kotlin compiler. Its goal is to improve interoperability between Kotlin and Swift by recreating features supported by both languages, but lost in the translation from Kotlin to Objective-C to Swift.

SKIE currently supports the following features:

- Coroutines interop
- Fixing unnecessarily mangled function names
- Sealed classes/interfaces
- Exhaustive enums
- Default arguments

To see how to add SKIE to your project, check out the [Installation doc](/docs/Installation.mdx).

*Please note that SKIE is still under active development, has not been publicly released, and it's use should be considered experimental.*

## Coroutines Interop

While it's possible to use Kotlin Coroutines in KMP, the support is far from complete.
Both `suspend` functions and `Flows` have limitations that make their usage from Swift cumbersome.
One of the main goals of SKIE is to change that by utilizing the Swift Async API which was added in Swift 5.5.

### Enabling coroutines interop

SKIE's coroutines interop is enabled by default.
However, consider disabling it if you are not using coroutines in your exported code.
Reason being is that, if enabled, SKIE adds dependency on `kotlinx-coroutines` and SKIE runtime library.
If those libraries are not needed, including them would (albeit slightly) increase binary size and compilation time.

SKIE automatically adjusts the min OS version of the produced Frameworks to ensure that the Swift Async API is available.
As a result, with coroutines interop enabled you cannot target older OS versions - for example, anything older than iOS 13.
If you need to target older OS versions, you must disable the interop as described below.

To disable the interop use the following Gradle configuration:

```kotlin title=build.gradle.kts
skie {
    features {
        coroutinesInterop.set(false)
    }
}
```

(You can learn more about the Gradle configuration [here](/docs/Configuration/Configuration.md)).

### Suspend functions

The problem with suspend functions is that ObjC has no equivalent feature.
Therefore, when the Kotlin compiler generates ObjC it must expose suspend functions as callbacks.
This approach has the several significant drawbacks:

- It has an ugly syntax that leads to callback hell (which is what suspend functions were meant to solve in the first place).
- Suspend function can be by default only called from Swift from the main thread (otherwise it results in a runtime crash).
  - Note: Kotlin 1.7.20 added a compiler flag that enables this feature.
    However, it only works with the regular (non `native-mt`) version of Coroutines.
    See [KT-51297](https://youtrack.jetbrains.com/issue/KT-51297/Native-allow-calling-Kotlin-suspend-functions-on-non-main-thread-from-Swift) for more information.
- It's not possible to cancel execution of such function from Swift.

The ugly syntax was already solved when Swift 5.5 added `async`/`await` with interop for legacy ObjC functions.
With that change, Kotlin suspend functions can now also be called using the `async`/`await` syntax.
For example: `suspend fun foo(): Int = 0` can now be called as `let result = try? await foo()`.

But this was just a syntax change, the other problems were unaffected.
SKIE lifts the remaining restrictions by generating Swift wrapper functions.
From the user perspective these wrappers are (almost) transparent.
They have the same signature, so you mostly don't need to change existing code. (Except in the case of generic classes as explained below.)

These wrappers can be called from any thread, and they also bridge cancellation between Swift and Kotlin.
Meaning you can cancel Kotlin suspend function from Swift as you would with any other Swift async function.
If the suspend function is canceled from Kotlin, the Swift caller receives `CancellationError` as would be the case with regular Swift async functions.
Therefore, from Swift point of view Kotlin suspend functions are indistinguishable from true Swift async functions.
And the called suspend function behaves as if it was called from another Kotlin suspend function.

These wrappers are generated for all types of suspend functions (global functions, member functions, extensions).
However, there is one big limitation: generic classes.
In the case of generic classes it's impossible to generate the same Swift wrapper as for other functions. (Due to limitations in Swift-ObjC interop.)

This limitation is very similar to Kotlin interface extensions (ObjC supports only class extensions).
The Kotlin compiler circumvents this problem by generating the function as a static function in the file class.
For example:

```kotlin title=I.kt
interface I

// The `foo` function is exported as `IKt.foo(_:)` (the first parameter is the extension receiver).
fun I.foo()
```

SKIE does the same thing for suspend functions of generic classes (both for member functions and extensions).
For example:

```kotlin title=A.kt
class A<T> {

    suspend fun foo(): Int = 0
}
```

Which can be called like so:

```swift
try await AKt.foo(A<NSString>())
```

Another limitation is that the generated wrappers cannot be directly overridden (they are just extensions).
Instead, you have to override the original suspend method.
However, doing that might cause the cancellation support to not work properly.

SKIE hides the original methods by prefixing them with `__`.
Therefore, it's possible to override that method using it's prefixed name.
For example:

```kotlin
open class A {

    open suspend fun foo(): Int = 0
}
```

```swift
class B: A {

    override func __foo() async throws -> KotlinInt {
        return KotlinInt(1)
    }
}
```

But make sure to not call suspend functions by the prefixed name - use the generated wrapper instead. (Otherwise you would lose the benefits that SKIE brings.)

### Flows

Kotlin compiler does not have any specific support for Flows - they are treated as regular interfaces.
There are two main problems with this approach:
- Flows are exposed to Swift without generics (because they are interfaces and not classes).
- There is no easy way to consume Flows directly from Swift.

While it's technically possible to call the `collect` method from Swift, it's very verbose.
The root cause is that passing `suspend` lambda functions to Kotlin code cannot be done using regular Swift lambdas.
And even if this wasn't the case, it would still not be ideal, because the API wouldn't be intuitive to Swift developers.

Swift has its own version of Flows called `AsyncSequence`.
This API is very similar to Flows, however there are some important syntactical differences.
For example, in Swift the `collect` method is implemented as a special case of the `for` statement:

```kotlin
flow.collect {
    println(it)
}
```

vs.

```swift
for await it in asyncSequence {
    print(it)
}
```

Also, Swift libraries frequently use `AsyncSequence` (and they can't know anything about `Flows`).
Therefore, developers would have to constantly convert between these two types manually.

SKIE solves these problems by automatically converting `Flow` to a class that implements `AsyncSequence`.
Thanks to this conversion, you can use `Flow` with any function that expects `AsyncSequence` including Swift higher-order functions like `map(_:)` or `filter(_:)`.
The conversion is transparent in most cases (with exceptions explained below), and looks like this:

```kotlin
class A {

    fun flow(): Flow<Int> = flow(1, 2, 3)
}
```

```swift
// You can omit the explicit type
let flow: SkieSwiftFlow<KotlinInt> = A().flow()

for await it in flow {
    // No type cast (`it as! KotlinInt`) is needed because the generic type is preserved.
    let number: KotlinInt = it

    print(number)
}
```

Note: The above example showcased only function return types, but SKIE also supports properties and function parameters.

Conversion from `AsyncSequence` to `Flow` is not yet supported.
However, this direction is far less frequently needed for developing iOS applications with shared KMP code.

Due to implementation reasons, it's not possible to automatically support all types of Flows.
Each type must be explicitly implemented in SKIE (because it needs to be converted to its own class).
There are multiple frequently used flow types in the `kotlinx-coroutines` library - those are all supported.
However, custom types cannot be supported.
Note: The determining factor (to decide if the conversion can happen automatically) is the declared type not the actual/runtime type of the passed object.

Currently supported types are:
- `Flow` -> `SkieSwiftFlow`
- `SharedFlow` -> `SkieSwiftSharedFlow`
- `MutableSharedFlow` -> `SkieSwiftMutableSharedFlow`
- `StateFlow` -> `SkieSwiftStateFlow`
- `MutableStateFlow` -> `SkieSwiftMutableStateFlow`

Examples:

```kotlin
class CustomFlow<T> : Flow<T> { ... }

fun a(): Flow<Int> = flowOf(1, 2, 3) // -> SkieSwiftFlow<Int>

fun b(): Flow<Int> = CustomFlow<Int>() // -> SkieSwiftFlow<Int>

fun c(): StateFlow<Int> = MutableStateFlow<Int>(1) // -> SkieSwiftStateFlow<Int>

fun d(): CustomFlow<T> = CustomFlow<Int>() // -> CustomFlow<T> (which does not implement `AsyncSequence`)
```

All `SkieSwift*Flow` classes have implementations for all public methods from their corresponding interfaces.
However, they do not directly implement those interfaces.
The method signatures are in some cases changed, to better match Swift style.
For example, you can set the value of MutableStateFlow like so: `mutableStateFlow.value = 1`
(Without SKIE the `value` property setter is exposed as a method `setValue(_:)`.)

All `SkieSwift*Flow` classes also have their `SkieSwiftOptional*Flow` counterparts.
The only difference between them is whether the `Flow` elements are nullable or not.
So for example: `Flow<Int>` is mapped to `SkieSwiftFlow<Int>`, while `Flow<Int?>` is mapped to `SkieSwiftOptionalFlow<Int>`.
This distinction is necessary because of limitations in ObjC generics.

There are also `SkieKotlin*Flow` variants of all previously mentioned `SkieSwift*Flow` classes (as well as their optional counterparts).
These classes do implement the `Flow` interfaces, however they cannot implement the `AsyncSequence` protocol.
Internally, these classes are used as a stepping stone between `*Flow` and `SkieSwift*Flow`.
However, these Kotlin types are exposed to developers if the `Flow` occurs as a type argument.
For example:

```kotlin
class Wrapper<T>(val value: T)

fun wrappedFlow(): Wrapper<Flow<Int>> // -> Wrapper<SkieKotlinFlow<Int>>
```

All SKIE Flow types have conversion constructors.
For example, you can convert:
- `Flow` to `SkieKotlinFlow<T>` by `SkieKotlinFlow<Int>(flow)` (the generic type needs to be explicitly specified and is not checked even at runtime - make sure you are passing a compatible type)
- `SkieKotlinFlow<T>` to `SkieSwiftFlow<T>` by `SkieKotlinFlow(skieKotlinFlow)` (it's not possible to directly convert between `Flow` and `SkieSwiftFlow`)
- `SkieSwiftFlow<T>` to `SkieSwiftOptionalFlow<T>` by `SkieSwiftOptionalFlow(skieKotlinFlow)`
- `SkieKotlinFlow<T>` to `Flow` does not have to be converted because `SkieKotlinFlow` implements `Flow`.

`Skie*Flow` classes do not inherit from each other, unlike their corresponding interfaces.
Therefore, if you need to use for example `SkieSwiftStateFlow` as `SkieSwiftFlow`, you need to convert the object using the conversion constructors.

Warning: Avoid using `as!`, `as?` or `is` with `SkieKotlin*Flow` it may result in unpredictable behavior or a runtime crash.
The only exception (when it is safe and might be required) is right after calling one of the `SkieKotlin*Flow` constructors.
So for example, you can write `SkieKotlinFlow<KotlinInt>(swiftFlow) as! SkieKotlinFlow<KotlinNumber>` to change the generic argument (which is not possible with `SkieSwift*Flow`).
However, you cannot safely do `KotlinA().flow() as! SkieKotlinFlow<KotlinInt>`.

The reason is that in some situations, the target object is not of type `SkieKotlin*Flow` in runtime.
SKIE cannot always modify the object runtime type, and in such situations it modifies only the compile-time type.
If you try to force cast such object, you will get approximately this runtime error `Expected xyz but found Kotlin_kobjcc0`.

You may run into this type of issue if you use a Swift generic container that internally uses force cast on the contained object, for example: `Swift.Array`.
To avoid this issue SKIE does not translate `Flow` types used as type arguments of known problematic declarations.
For example:
- `List<Flow<*>>`
- `Map<*, Flow<*>>`
- `Flow<Flow<*>>`

In such cases you can still use the conversion constructors: `listOfFlows.map { SkieSwiftFlow(SkieKotlinFlow<KotlinInt>($0)) }`

Because `SkieSwift*Flow` are Swift classes, their type parameters don't have to conform to `AnyObject`.
This fact allows us to better support ObjC types that are bridged to Swift types (by the Swift compiler).
One such class is `NSString`, which is bridged to `String`.
Usually `Kotlin.String` is exposed as `NSString` if it's used as type argument.
With `SkieSwift*Flow` you can utilize the following syntax to avoid manual casting:

```kotlin
class A {

    fun flow(): Flow<String> = flow("1", "2", "3")
}
```

```swift
// In this case the explicit type forces Swift to use String (by default the type would be infered to SkieSwiftFlow<NSString>)
let flow: SkieSwiftFlow<String> = A().flow()

for await it in flow {
    // No type cast (`it as! String`) is needed because the generic type is preserved.
    let number: String = it

    print(number)
}
```

Alternatively:

```swift
// In this case Swift infers correct type from the variable type
for await it: String in A().flow() {
    // No type cast (`it as! String`) is needed because the generic type is preserved.
    let number: String = it

    print(number)
}
```

## Fixing unnecessarily mangled function names

Kotlin, ObjC and Swift each have a different level of support for function overloading.
Kotlin distinguishes overloads by their parameter types.
ObjC uses argument labels (parameter names in Kotlin) but does not use the parameter types.
Swift combines these two approaches and allows for overloads to have the same parameters types if some argument labels are different.

The Kotlin compiler solves these differences by adding `_` at the end of the function identifier (or at the end of the last argument label).
The problem, that SKIE addresses, is that the Kotlin compiler uses the same conflict detection rules for both ObjC and Swift.
As a result Swift function names are in many occasions unnecessarily mangled. For example:

```kotlin
fun foo(i: Int)

fun foo(i: String)
```

would translate to: `foo(i:)` and `foo(i_:)` - even-though the underscore is not necessary for Swift to call the correct function.

SKIE implements its own conflict resolution algorithm that removes these unnecessary underscores.

However, there are still some occasions where these underscore are necessary (meaning SKIE cannot remove them):

*Non-exposed classes used as parameter type* - Some types (like Value classes) are not exposed to ObjC.
Instead, the compiler replaces these types with some other supported type (in case of value classes it's the wrapped type).
For this reason some functions might end up with the same signature in Swift (even-though they have different signatures in Kotlin).
For example:

```kotlin
value class V(val value: Int)

fun foo(v: V)

fun foo(v: Int)
```

*Properties and parameterless functions* - In Kotlin it's completely fine to have a property with the same name as a parameterless functions.
For example:

```kotlin
fun foo(): Int

val foo: Int
```

The problem is that Swift cannot distinguish these two declarations.
This is not an issue you would notice without using SKIE because the Kotlin compiler uses a different workaround.
Unfortunately, this workaround cannot be used by SKIE because it only works due to the Swift-ObjC interop.
SKIE generates true Swift code, and therefore, SKIE has no option but to add these underscores.

## Sealed classes/interfaces

SKIE allows you to exhaustively switch on sealed Kotlin hierarchies from Swift. For example, consider the following Kotlin code:

```kotlin
sealed interface KotlinSealedInterface {
    class Success(val data: List<Any>) : KotlinSealedInterface
    class Error(val message: String) : KotlinSealedInterface
    object Loading : KotlinSealedInterface
}
```

In Kotlin you can write this:

```kotlin
when (sealedInterface) {
    is KotlinSealedInterface.Success -> configureWithData(sealedInterface.data)
    is KotlinSealedInterface.Error -> configureForErrorMessage(sealedInterface.message)
    is KotlinSealedInterface.Loading -> configureForLoading()
}
```

In the above example, the compiler ensures that the `when` expression lists all possible cases (i.e. that it is exhaustive). The compiler also smart-casts the `sealedInterface` expression to the correct type. The smart-cast allows the developer to access the inner properties of each type without an additional cast.

To support this feature in Swift, SKIE generates code that can be reduced to this:

```swift
enum SwiftWrapperEnum {
    case Success(KotlinSealedInterfaceSuccess)
    case Error(KotlinSealedInterfaceError)
    case Loading(KotlinSealedInterfaceLoading)
}

func onEnum(of sealed: KotlinSealedInterface) -> SwiftWrapperEnum {
    if let sealed = sealed as? KotlinSealedInterfaceSuccess {
        return SwiftWrapperEnum.Success(sealed)
    } else if let sealed = sealed as? KotlinSealedInterfaceError {
        return SwiftWrapperEnum.Error(sealed)
    } else if sealed is KotlinSealedInterfaceLoading {
        return SwiftWrapperEnum.Loading
    } else {
        fatalError("Unknown subtype. This error should not happen under normal circumstances since KotlinSealedInterace is sealed.")
    }
}
```

The `onEnum(of:)` function wraps the Kotlin object in a Swift enum.

SKIE leverages the fact that Swift `switch` statements **do not** always require a `default` case. A `default` is **not
** required if every possible value of the type being considered is matched by one of the `switch` statement's cases (e.g. a `switch` that takes an enum and has a `case` for each and every `case` in that enum.)

To simulate Kotlin's smart-casting we use an enum with associated values.

Thanks to the above code you can now write this:

```swift
switch onEnum(of: sealedInterface) {
case .Success(let sealedInterface):
    configureForSuccess(withData: sealedInterface.data)
case .Error(let sealedInterface):
    configureForError(withMessage: sealedInterface.message)
case .Loading:
    configureForLoading()
}
```

If you do not need the smart-casting, you can write just this:

```swift
switch onEnum(of: sealedInterface) {
case .Success:
    print("success!")
case .Error:
    fatalError()
case .Loading:
    configureForLoading()
}
```

## Exhaustive enums

The Kotlin compiler (without SKIE) generates Kotlin enums as Objective-C classes (albeit with restricted subclassing). As a result, Swift code cannot leverage some of its language features in regards to enums (mainly exhaustive switching).

SKIE adds back this functionality by generating a Swift version of the given Kotlin enum. The Swift enum is accessible without any extra code (like the `onEnum` in the case of sealed classes).

For example, consider following Kotlin code:

```kotlin
enum class Direction {
    NORTH, SOUTH, EAST, WEST
}
```

Without SKIE you would be required to include a `default` case, even if your switch is exhaustive:

```swift
switch (direction) {
case .north: print("NORTH")
case .south: print("SOUTH")
case .east: print("EAST")
case .west: print("WEST")
default: print("Unknown")
}
```

However, with SKIE, the `default` case is no longer necessary. Instead, you will see a compiler warning similar to this one:

```
warning: default will never be executed
default: print("Unknown")
```

## Default arguments/parameters

Default arguments (or parameters) are a feature in both [Kotlin](https://kotlinlang.org/docs/functions.html#default-arguments) and [Swift](https://docs.swift.org/swift-book/LanguageGuide/Functions.html#ID169) that allows caller functions to omit arguments when the missing arguments are provided by the called function. Unfortunately, Objective-C does not support default arguments in any way. Therefore, Swift must always specify all arguments when calling Kotlin functions.

Default arguments are implemented differently in Kotlin and Swift, so the two languages have different semantics for the feature. For example, Kotlin default arguments can access the values of previous function parameters as well as the `this` expression (which is `self` in Swift).

However, Swift default parameters must be globally available. As a result, SKIE cannot generate Swift functions with default arguments (at least not in all cases). To solve this issue, SKIE generates Kotlin overloads of the given functions to match all possible ways to call that functions.

For example, let's take a `data class`:

```kotlin
data class User(
    val name: String,
    val age: Int
)
```

Kotlin data classes have an automatically generated method named `copy` that creates a new instance of the data class with some values modified. For our data class `User` up above, the method can be written as:

```kotlin
fun User.copy(name: String = this.name, age: Int = this.age) = User(name, age)
```

Without SKIE the `copy` method is exposed to Swift under the following signature: `User.doCopy(name:age:)` due to a naming collision with an Objective-C method named `copy`. Since Swift cannot use Kotlin default arguments, all parameters must be provided, which defeats the purpose of the Kotlin `copy` method.

SKIE generates additional Kotlin overloads, that are visible from Swift under the following signatures:

- `User.doCopy()`
- `User.doCopy(name:)`
- `User.doCopy(age:)`

These overloads allow Swift to call `copy` method as if the default arguments were directly supported.

### Limitations

While this approach to default arguments is completely transparent from Swift, it has some drawbacks:

- It does not support interface methods (all other types of functions are supported, including interface extensions).
- The number of generated overloads is `O(2^n)` where `n` is the number of default arguments (not all parameters).

Since it is not possible to generate exponential numbers of functions, the number of default arguments supported is limited to 5, so that at most 31 additional functions will be generated per function with default arguments. If a function has more than 5 default arguments, SKIE will not generate any extra functions.

The limit of 5 was chosen as the result of internal experiments, but that number might change. For now, we think it's a suitable balance between the number of supported cases (since not many functions exceed that number) and the overhead introduced in the form of compilation time and binary size.

The maximum number of default arguments can be explicitly configured using the `DefaultArgumentInterop.MaximumDefaultArgumentCount` key/annotation (see the Local section of [the Configuration doc](/docs/Configuration/Configuration.md).

*NOTE: All of the above-mentioned problems might be mitigated in the future versions of SKIE. For instance, the limit on
the number of default arguments may increase in the future as we test the plugin on larger projects.*
