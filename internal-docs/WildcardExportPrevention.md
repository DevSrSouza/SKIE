# Wildcard export prevention

This document describes "wildcard export prevention", why it's needed and what can happen when users disable it.

## Problem

By default, Kotlin framework (and other Objective-C frameworks) re-exports all modules it depends on. Example modulemap file:

```
framework module Kotlin {
    umbrella header "Kotlin.h"

    export *
    module * { export * }

    use Foundation
}
```

The line `export *` and `module * { export * }` does the re-export. The result of it is, that doing `import Kotlin` in Swift will also make transitive symbols available. For example, all symbols from `Foundation` will be available in that Swift file, without needing to `import Foundation` explicitly.

Normally that's not an issue. It might be slightly inconvenient, that you can't use code completion to know what exactly is brought in by the Kotlin framework, but that's about it. However, when we add the Swift overlay to the framework, an issue emerges. If the Kotlin framework contains a declaration with the same Swift name as any declaration in its dependencies, it can result in consumer Swift not being able to access either. The situation differs based on what's imported in the consumer Swift file.

Let's say the Kotlin framework contains the following file:

```kotlin
class Locale {

}
```

Then the resulting framework will contain a symbol `KotlinLocale` with the Swift name set to `Locale`. By default, any Kotlin framework depends on and thus re-exports `Foundation`. `Foundation` has a symbol `NSLocale` in it with the Swift name being `Locale`.

Now the first example is when you only `import Kotlin`. This will succeed and the type it accesses is the Kotlin class `Locale`. So far so good. Notice we can also use the fully qualified name `Foundation.Locale` to access the class from `Foundation`. Additionally, we can access the reference to Kotlin's `Locale` initializer.

```swift
import Kotlin

let locale: Locale = Locale()
let foundationLocale: Foundation.Locale = Foundation.Locale()

let localeFactory: () -> Locale = Locale.init
```

It all changes once we add `import Foundation` to the same file, or if we import a different module that's also re-exports `Foundation`.

```swift
import Foundation
import Kotlin

let locale: Locale = Locale() // <- 'Locale' is ambiguous for type lookup in this context
let foundationLocale: Foundation.Locale = Foundation.Locale()

let localeFactory: () -> Locale = Locale.init // <- 'Locale' is ambiguous for type lookup in this context
```

You might think that all we need to do, is use the qualified name, replacing `Locale` with `Kotlin.Locale`. But it's not the case, it just results in a slightly different error message `Ambiguous type name 'Locale' in module 'Kotlin'`.

**NOTE [TK]**: It's possible there's a configuration or something that fixes this behavior. I haven't found it and I spent a lot of time trying. It _might_ be worthwhile to try looking for it again later.

## Workaround

To work around this issue, SKIE removes the re-export from the Kotlin framework's modulemap file. Notice the two lines missing:

```
framework module Kotlin {
    umbrella header "Kotlin.h"

    use Foundation
}
```

The downside is, that for projects that use symbols from the `Foundation` module without importing it, will fail compilation with SKIE and will require developers to add `import Foundation` to these files. To help with the transition, we have disabling this behavior by `skie.isWildcardExportPrevented.set(false)` in `build.gradle.kts` file.

Another reason for having this user-configurable is, that we don't know for sure it's okay to disable the re-export. At Swift forums, some developers on Swift Core team mentioned that basically just `export *` works properly. They haven't mentioned whether that includes not having it at all or not, so we don't know. We only know it works now with what we have.

## Possible SKIE compilation errors

If a developer disables the _wildcard export prevention_, SKIE's Swift compilation may fail if the developer also has a class with a conflicting name in their Kotlin code. So for example if they have the class `Locale` and disable the _wildcard export prevention_ the compilation will fail when and only when SKIE is applied.

We tried to work around the issue by replacing `import Foundation` in Swift files generated by SKIE with `@_implementationOnly import Foundation`. While that works, it has two flaws. For one, the `@_implementationOnly` attribute should be used. It's an internal attribute that has issues and can lead to runtime crashes when used improperly (not our case). The other one is behavior inconsistency.

Say the developer has _wildcard export prevention_ disabled and has a class `Locale`. When we use the `@_implementationOnly` attribute for the `Foundation` import, SKIE will compile successfully. But only as long as no generated Swift needs to use `Foundation` symbols in the public API. For example, the developer adds a method to an enum class, that returns a generic type (`Foo<T>`) with the type argument being a `String`. It results in SKIE generating a proxy function to the generated Swift enum. This proxy function returns `Foo<NSString>` as that's the correct type `Foo<String>` translated to. Because `NSString` is from `Foundation`, SKIE has to drop the `@_implementationOnly` attribute. The result is, SKIE compilation starts crashing on completely unrelated `Locale` class.

Because of these two issues, we decided against using the `@_implementationOnly` attribute. Instead, anyone who disables the _wildcard export prevention_ will have to make sure their type names don't create conflicts with any ObjectiveC module they depend on.
